/*^
  ===========================================================================
  TwoBinManager
  ===========================================================================
  Copyright (C) 2016-2017 Gianluca Costa
  ===========================================================================
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as
  published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public
  License along with this program.  If not, see
  <http://www.gnu.org/licenses/gpl-3.0.html>.
  ===========================================================================
*/

package info.gianlucacosta.twobinmanager.generators.guillotine.algorithm

import info.gianlucacosta.twobinpack.core._

import scala.util.Random
import scalafx.scene.paint.Color

/**
  * Guillotine cuts generator algorithm.
  *
  * Its algorithm is based on 3 steps:
  *
  * <ol>
  * <li>
  * Partition the frame height in rows having random height
  * </li>
  *
  * <li>
  * Independently partition every row into columns, each having random width
  * </li>
  *
  * <li>
  * Independently partition every column of the previous step into subrows, each having
  * random height: every subrow becomes an anchored block
  * </li>
  * </ol>
  *
  * The algorithm provides full frame coverage; fewer blocks can be generated by reducing
  * the selection probability - which is applied after generating the blocks.
  */
object GuillotineAlgorithm {
  /**
    * Generates the template for a Knapsack frame and the related blocks, which
    * are placed according to guillotine cuts.
    *
    * @param frameDimension            The dimension of the frame
    * @param maxBlockDimension         The maximum block size allowed
    * @param canRotateBlocks           Whether the user can rotate blocks
    * @param blockSelectionProbability Probability (in range [0;1] of block selection.
    *                                  If 1, the whole frame will be covered by blocks
    * @param blockColorsPool           A list of colors used to paint the blocks
    * @param resolution                The number of pixels per quantum unit
    * @return The FrameTemplate object and the set of anchored blocks
    */
  def createRandomKnapsack(
                            frameDimension: FrameDimension,
                            maxBlockDimension: BlockDimension,
                            canRotateBlocks: Boolean,
                            blockSelectionProbability: Double,
                            blockColorsPool: List[Color],
                            resolution: Int
                          ): (FrameTemplate, Set[AnchoredBlock]) = {
    require(
      maxBlockDimension.width <= frameDimension.width,
      "The maximum block width cannot be greater than the frame width"
    )

    require(
      maxBlockDimension.height <= frameDimension.height,
      "The maximum block height cannot be greater than the frame height"
    )

    require(
      0 <= blockSelectionProbability && blockSelectionProbability <= 1,
      "The block selection probability must be in the range [0; 1]"
    )

    require(
      blockColorsPool.nonEmpty,
      "At least one block color must be passed"
    )

    require(
      Problem.MinResolution <= resolution && resolution <= Problem.MaxResolution,
      s"The resolution must be in the range [${Problem.MinResolution}..${Problem.MaxResolution}]"
    )


    val blocks: Set[AnchoredBlock] =
      createBlocks(
        frameDimension,
        maxBlockDimension,
        blockSelectionProbability
      )


    val blockDimensions: Map[BlockDimension, Int] =
      blocks
        .groupBy(_.dimension)
        .map {
          case (dimension, groupedBlocks) =>
            dimension -> groupedBlocks.size
        }


    val blockPool =
      BlockPool.create(
        canRotateBlocks,
        blockDimensions
      )


    val frameTemplate =
      FrameTemplate(
        frameDimension,
        FrameMode.Knapsack,
        blockPool,
        blockColorsPool,
        resolution
      )

    (frameTemplate, blocks)
  }


  private def createBlocks(
                            frameDimension: FrameDimension,
                            maxBlockDimension: BlockDimension,
                            blockSelectionProbability: Double)
  : Set[AnchoredBlock] = {
    val widthSegment =
      QuantizedSegment(frameDimension.width)


    val heightSegment =
      QuantizedSegment(frameDimension.height)


    val rows: List[Row] =
      heightSegment
        .createRandomPartition(maxBlockDimension.height)
        .foldLeft(
          (
            List[Row](),
            0
          )
        ) {
          case ((cumulatedRows, currentTop), rowSegment) =>
            val currentHeight =
              rowSegment.length

            val row =
              Row(
                top =
                  currentTop,

                height =
                  currentHeight
              )

            (
              row :: cumulatedRows,
              currentTop + currentHeight
            )
        }._1


    val columns: List[Column] =
      rows.flatMap(row => {
        val columnSegments: List[QuantizedSegment] =
          widthSegment.createRandomPartition(maxBlockDimension.width)

        columnSegments
          .foldLeft(
            (
              List[Column](),
              0
            )
          ) {
            case ((cumulatedRowColumns, currentLeft), columnSegment) =>
              val currentWidth =
                columnSegment.length

              val column =
                Column(
                  row,

                  left =
                    currentLeft,

                  width =
                    currentWidth
                )

              (
                column :: cumulatedRowColumns,
                currentLeft + currentWidth
              )
          }._1
      })


    val fullCoverageBlocks: List[AnchoredBlock] =
      columns.flatMap(column => {
        val columnHeightSegment =
          QuantizedSegment(column.row.height)

        val blockSegments: List[QuantizedSegment] =
          columnHeightSegment.createRandomPartition(column.row.height)


        blockSegments.foldLeft(
          List[AnchoredBlock](),
          0
        ) {
          case ((cumulatedColumnBlocks, currentTopWithinRow), blockSegment) =>
            val currentBlockHeight =
              blockSegment.length

            val block =
              AnchoredBlock.createFromTopLeft(
                BlockDimension(
                  column.width,
                  currentBlockHeight
                ),

                QuantizedPoint2D(
                  column.left,
                  column.row.top + currentTopWithinRow
                )
              )

            (
              block :: cumulatedColumnBlocks,
              currentTopWithinRow + currentBlockHeight
            )
        }._1
      })


    val filteredBlocks =
      fullCoverageBlocks.filter(_ =>
        Random.nextDouble() <= blockSelectionProbability
      )

    filteredBlocks.toSet
  }
}
